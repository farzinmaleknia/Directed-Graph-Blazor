@inject IJSRuntime JsRuntime
@inject NavigationManager Navigation


@if(isBodyLoaded)
{
	<div class="bg-dark bg-opacity-50" style="@($"position: absolute; height: {HeightMain}px; width: {WidthMain}px; top: 0; left: 0;")">

		<div class="d-flex flex-row-reverse mt-2 mx-4">
			<button class="btn btn-light btn-sm rounded-circle" style="margin-right:5px; z-index: 100;" title="Close" @onclick="Close">
				<i class="mdi mdi-close mdi-24px"></i>
			</button>
			<button class="btn btn-light btn-sm rounded-circle" style="margin-right:5px; z-index: 100;" title="Refresh Psitions" @onclick="() => RefreshVertexPositions(true)">
				<i class="mdi mdi-adjust mdi-24px"></i>
			</button>
			<button class="btn btn-light btn-sm rounded-circle" style="margin-right:5px; z-index: 100;" title="Recenter graph" @onclick="() => RefreshVertexPositions(false)">
				<i class="mdi mdi-image-size-select-small mdi-24px"></i>
			</button>
			<button class="btn btn-light btn-sm rounded-circle" style="margin-right:5px; z-index: 100;" title="Filter by order : All / To Stores / Stores to / Not stores / Not in groups " @onclick="OnEdgeFilterClicked">
				<i class="mdi mdi-filter mdi-24px"></i>
			</button>
		</div>

		<div id="Zoomable" class="bg-dark bg-gradient" style="@($"position: absolute; height: {HeightMain * 0.9}px; width: {WidthMain * 0.9}px; top: {HeightMain * 0.05}px; left: {WidthMain * 0.05}px;")">
			<div id="directed-graph" class="bg-dark" style="@($"position: absolute; height: {((HeightMain * 0.9) - 10)}px; width: {(WidthMain * 0.9 - 10)}px; top: 5px; left: 5px;")">
				@(isHtmlRenderd = true)
				@if (Height > 0)
				{
					<VertexRenderer graph="graph"
						Height="@Height"
						Width="@Width"
						Top="@Top"
						Left="@Left"
						isFirstRender="@orderToReposition"
						OnVertexChanged="passingVertexFromVertexRenderer"/>

					<EdgeRenderer graph="@graph"
						EdgeFilter="@EdgeFilterValue"
						passedVertex="@passingVertexForFilter"/>
				}
			</div>
		</div>

	</div>

	<div class="modal fade" id="optionModel" tabindex="-1" aria-labelledby="optionModelLabel" aria-hidden="true">
		<div class="modal-dialog modal-dialog-centered" style="width:216px;">
			<div class="modal-content">
				<div class="modal-body">
					<div>
						<button type="button" class="btn btn-primary btn-sm" title="Filter this vertex" data-bs-dismiss="modal" @onclick="OnFilterOneVertex">
							Filter this vertex
						</button>

						<button type="button" class="btn btn-success btn-sm" title="Details" data-bs-toggle="modal" data-bs-target="#vertexModel">
							Details
						</button>
					</div>
				</div>
			</div>
		</div>
	</div>

	<div class="modal fade" id="vertexModel" tabindex="-1" aria-labelledby="vertexModelLabel" aria-hidden="true">
		<div class="modal-dialog modal-dialog-centered">
			<div class="modal-content">
				<div class="modal-body">
					<div>
						<div class="d-flex justify-content-between mb-3">
							<h1 class="modal-title fs-5" id="vertexModelLabel">@(passedVertex.Name)</h1>
							<button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
						</div>

						<ul style="list-style-type:none;">
							<li>
								<div class="row mb-2">
									<div class="col-sm-6">
										Total Connection :
									</div>
									<div class="col-sm-6">
										@(passedVertex.Adjacents.Count),
									</div>
								</div>
							</li>
							<li>
								<div class="row mb-2">
									<div class="col-sm-6">
										Total Entries :
									</div>
									<div class="col-sm-6">
										@(passedVertex.Entries.Count),
									</div>
								</div>
							</li>
							<li>
								<div class="row mb-2">
									<div class="col-sm-6">
										Total Departures :
									</div>
									<div class="col-sm-6">
										@(passedVertex.Adjacents.Count - passedVertex.Entries.Count),
									</div>
								</div>
							</li>
							<li>
								<div class="row mb-2">
									<div class="col-sm-6">
										All the connection :
									</div>
									<div class="col-sm-6">
										@foreach (var item in passedVertex.Adjacents)
										{
											<span>@(item), </span>
										}
									</div>
								</div>
							</li>
						</ul>
					</div>
				</div>
			</div>
		</div>
	</div>


}

@code {
	[Parameter]
	public Classes.DirectedGraph graph { get; set; }
	[Parameter]
	public EventCallback OnCloseGraph { get; set; }

	public Classes.Vertex passedVertex { get; set; }
	public Classes.Vertex passingVertexForFilter { get; set; }

	public List<string> EdgeFilterMode { get; set; }
	public string EdgeFilterValue { get; set; }
	private int EdgeFilterCounter { get; set; }

	private double HeightMain { get; set; }
	private double WidthMain { get; set; }
	private double Height { get; set; }
	private double Width { get; set; }
	private double Top { get; set; }
	private double Right { get; set; }
	private double Left { get; set; }

	private bool isBodyLoaded { get; set; }
	private bool stateNeeded { get; set; }
	private bool isHtmlRenderd { get; set; }

	private bool orderToReposition { get; set; }

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();

		passedVertex = new Classes.Vertex();

		isBodyLoaded = false;
		stateNeeded = true;
		isHtmlRenderd = false;
		orderToReposition = false;

		EdgeFilterValue = "";
		EdgeFilterCounter = 0;

		EdgeFilterMode = new List<string>() { "ToMain", "MainTo", "NotMain", "NotInGroup", ""};


		passedVertex = graph.GetVertexSet().First();

		await GetBodyDimention();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{

		//foreach(var item in graph.GetVertexSet())
		//{
		//	Console.WriteLine($"{item.Name} - {item.X} - {item.Y}");
		//}

		if (!firstRender)
		{
			if (!isBodyLoaded)
			{
				await GetBodyDimention();

				StateHasChanged();
			}
			if (isBodyLoaded)
			{
				await GetBackGroundDimention();

			}
		}


		await base.OnAfterRenderAsync(firstRender);
	}

	public async Task GetBodyDimention()
	{
		Dictionary<string, string> displayDimention = await JsRuntime.InvokeAsync<Dictionary<string, string>>("getElementDimension", "body");

		WidthMain = double.Parse(displayDimention["width"]);
		HeightMain = double.Parse(displayDimention["height"]);

		if (HeightMain > 100)
		{
			isBodyLoaded = true;
		}
	}	

	public async Task GetBackGroundDimention()
	{
		if (isBodyLoaded && isHtmlRenderd)
		{
			//await Task.Delay(5000);
			Dictionary<string, string> BackgroundDimention = await JsRuntime.InvokeAsync<Dictionary<string, string>>("getElementDimension", "directed-graph");

			Width = double.Parse(BackgroundDimention["width"]);
			Height = double.Parse(BackgroundDimention["height"]);
			Top = double.Parse(BackgroundDimention["top"]);
			Left = double.Parse(BackgroundDimention["left"]);

			//Console.WriteLine($"top: {Top}, left: {Left}, height: {Height}, width: {Width}");

			if(stateNeeded)
			{
				StateHasChanged();
				stateNeeded = false;
			}
		}
	}

	public async Task Close()
	{
		await OnCloseGraph.InvokeAsync();
	}

	public async Task RefreshVertexPositions(bool alsoPositions)
	{
		orderToReposition = false;
		await JsRuntime.InvokeVoidAsync("refreshScale", "Zoomable", $"{(HeightMain) * 0.05}", $"{(WidthMain) * 0.05}");
		if(alsoPositions)
		{
			EdgeFilterCounter = 4;
			orderToReposition = true;
			await GetBackGroundDimention();
		}

	}

	public void passingVertexFromVertexRenderer(Classes.Vertex vertex)
	{
		passedVertex = vertex;
	}

	public void OnEdgeFilterClicked()
	{
		orderToReposition = false;
		EdgeFilterValue = EdgeFilterMode[EdgeFilterCounter];

		if(EdgeFilterCounter == 4)
		{
			EdgeFilterCounter = 0;
		}
		else
		{
			EdgeFilterCounter++;
		}
	}

	public void OnFilterOneVertex()
	{
		orderToReposition = false;
		passingVertexForFilter = passedVertex;
		EdgeFilterValue = "OneVertex";
		EdgeFilterCounter = 4;
	}
}
