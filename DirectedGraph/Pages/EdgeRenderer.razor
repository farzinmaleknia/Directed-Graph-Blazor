@inject IJSRuntime JsRuntime

<div>
    @foreach (var edge in graph.GetEdgeSet())
    {
        if (EdgeFilterMethod(EdgeFilter, edge))
        {
            <div style='border: none; border-top: 1px dashed gray; z-index: 10; color:gray; padding:0px; margin:0px; height: 0.1px; background-color: none; line-height:0.1px; position:absolute; left: @(edge.Cx)px; top:@(edge.Cy )px; width:@(edge.Length)px; -moz-transform:rotate(@(edge.Angle)deg); -webkit-transform:rotate(@(edge.Angle)deg); -o-transform:rotate(@(edge.Angle)deg); -ms-transform:rotate(@(edge.Angle)deg); transform:rotate(@(edge.Angle)deg);'>
                <div style="padding-left: @($"{(edge.End.IconSize / 2)* 0.6}px")" title="@($"From : {edge.Start.Name} \nTo : {edge.End.Name}")">
                   @arrow
                </div>
            </div>
        }
    }
</div>



@code {

    [Parameter]
    public Classes.DirectedGraph graph { get; set; }

    [Parameter]
    public string EdgeFilter { get; set; }

    [Parameter]
    public Classes.Vertex passedVertex { get; set; }

    [Parameter]
    public List<Classes.Vertex> passedGroup { get; set; }

    private string arrow { get; set; } = "<";




    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        passedVertex = new Classes.Vertex();
        passedGroup = new List<Classes.Vertex>();

        EdgeFilter = "";


    }

    protected override async Task OnParametersSetAsync()
    {
        await base.OnParametersSetAsync();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            string json = Newtonsoft.Json.JsonConvert.SerializeObject(graph);

            Console.WriteLine(json);
        }


        await base.OnAfterRenderAsync(firstRender);
    }

    public bool EdgeFilterMethod(string filter , Classes.PairValueImplementation<Classes.Vertex> edge)
    {

        bool condition;

        switch (filter)
        {
            case "ToMain":
                if (edge.End.IsStore)
                {
                    condition = edge.End.IsStore;
                    return condition;

                }else
                {
                    return false;
                }
            case "MainTo":
                condition = edge.Start.IsStore;
                return condition;
            case "NotMain":
                condition = !edge.Start.IsStore && !edge.End.IsStore;
                return condition;
            case "OneGroup":
                condition = false;
                foreach (var v in passedGroup)
                {
                    if (v.Name == edge.Start.Name || v.Name == edge.End.Name)
                    {
                        condition = true;
                        break;
                    }
                }
                return condition;
            case "OneVertex":
                condition = edge.Start.Name == passedVertex.Name || edge.End.Name == passedVertex.Name;
                return condition;
            default:
                return true;
        }
    }
}
