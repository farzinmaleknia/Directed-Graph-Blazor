@inject IJSRuntime JsRuntime

@if (Width > 0 && Height > 0)
{
	@foreach (var item in graph.GetVertexSet())
	{
		<div class="text-white" style="@($"z-index: 1000; position: absolute; left: {GetRandomX(item, Width)}px; top: {GetRandomY(item, Height)}px;")" title="@($"Name : {item.Name} \nEntries Count : 3")">
			<i class="mdi mdi-circle-small mdi-36px"></i>

		</div>

	}
}

@code {
	[Parameter]
	public Classes.DirectedGraph<Classes.Vertex, string> graph { get; set; }

	[Parameter]
	public double Height { get; set; }
	[Parameter]
	public double Width { get; set; }
	[Parameter]
	public double Top { get; set; }
	[Parameter]
	public double Right { get; set; }
	[Parameter]
	public double Left { get; set; }

	private int Counter { get; set; } = 1;

	protected override async Task OnInitializedAsync()
	{
		await base.OnInitializedAsync();
	}


	// These two method divided the area  to six part, so the points ....
	public double GetRandomX(Classes.Vertex vertex, double max)
	{
		if (Counter == 7)
			Counter = 1;
		Random number = new Random();
		double num = 0;
		switch (Counter)
		{
			case 1: case 4:
				num = number.NextDouble() * ((max/3) - 50) + 50;
				vertex.X = num;
			return num;
			case 2: case 5:
				num = number.NextDouble() * (((max / 3) * 2) - (max / 3)) + (max / 3);
				vertex.X = num;
				return num;
			case 3: case 6:
				num = number.NextDouble() * ((max - 50) - ((max / 3) * 2)) + ((max / 3) * 2);
				vertex.X = num;
				return num;
			default:
				return 0;
		}
	}

	public double GetRandomY(Classes.Vertex vertex, double max)
	{
		Random number = new Random();
		double num = 0;
		switch (Counter)
		{
			case 1: case 2: case 3:
				Counter++;
				num = number.NextDouble() * ((max / 2) - 50) + 50;
				vertex.Y = num;
				return num;
			case 4: case 5: case 6:
				Counter++;
				num = number.NextDouble() * ((max - 50) - (max / 2)) + (max / 2);
				vertex.Y = num;
				return num;
			default:
				return 0;
		}
	}	
}
